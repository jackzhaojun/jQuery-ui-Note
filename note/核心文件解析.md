jQuery-ui 所有的扩展类都必须引入的两个核心js

1. jquery.ui.core.js
2. jquery.ui.widget.js

##jquery.ui.core.js
core.js 主要是扩展了一些工具类

* focus  
* scrollParent
* zIndex
* uniqueId
* removeUniqueId

## jquery.ui.widget.js
---
jquery.ui.widget.js是ui扩展的真正核心文件，
jquery.ui.widget.js定义了三个重要的函数

* $.widget
* $.widget.bridge
* $.Widget(注意这个W是大写的和上面的$.widget不是一个函数)
 
下来看下**$.widget**次函数自定义ui的入口此函数有三大作用

1. 生成自定义UI的constructor (后续通过new constructor来完成自定义UI的初始化)
2. 对自定义UI函数的包装（包装的目的是为了让自定义UI方便调用被重写的base原生函数）
3. 当自定义UI被重新定义时的处理方式

接下来看**$.widget**函数体

>  * name String 此参数就是要定义的扩展UI名字 eg: "ui.dialog"
>  * base constructor 此参数定义了UI的基础运行机制和一些工具函数
>  * prototype Object 此参数为自定义扩展的原型，包含自定义扩展的各种属性和方法

    $.widget = function( name, base, prototype ) { 
       ...
       code line 33
       if ( !prototype ) {
            prototype = base;
            //看这里 如果base没有传得话 会默认为$.Widget 此处W是大写不要和$.widget混淆
		    base = $.Widget;
	    }
        ...
        code line 45
        constructor = $[ namespace ][ name ] = function( options, element ) {
    		...
            这段代码体现了上面提到的作用1
    	};
        ...
        code line 75
        $.each( prototype, function( prop, value ) {
            ... 此处省略代码N行
            这里体现了上面提到的作用2
        })
        ...
        code line 121
        这里体现了上面提到的作用3
        吐槽下 感觉这段代码有问题啊，根本没有做到UI的重新定义处理
        if ( existingConstructor ) {
    	$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;
            
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
    		delete existingConstructor._childConstructors;
    	} else {
            //感觉这里有问题啊。为毛要放到base
    		base._childConstructors.push( constructor );
    	}
    }
    
 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
